var tipuesearch = {"pages":[{"title":"Visual Sitemap","text":"    Summary  Using a very simple JSON file schema to define the structure of your website, this project uses that structure to generate a beautiful, visual HTML sitemap.  The final document has all icons and CSS embedded in it and can be shared with other team members easily.  The primary fonts use Google Fonts and require internet access, however the fallback fonts work just fine offline.  Take a look at example.json to see what a definition file looks like.  Open example.html in a browser to see the example visual sitemap.  Visit https:\/\/aklump.github.io\/visual_sitemap for full documentation.  Quick Start   Once you've installed vismap, create a new data file thus vismap {FILENAME}.json -c Replace the contents of that file with real content. In Terminal type vismap {FILENAME}.json to compile the sitemap. Open {FILENAME}.html in a browser.   Requirements   You will need Composer for installing. You will need a text editor to edit JSON files. You will need a command line terminal to generate the map.   Contributing  If you find this project useful... please consider making a donation.  Installation  Install Globally Using Composer  To be able to use the commands from any directory in your CLI you may want to install this globally.  composer global require aklump\/visual-sitemap   Make sure you have the composer bin dir in your PATH. The default value is ~\/.composer\/vendor\/bin, but you can check the value that you need to use by running composer global config bin-dir --absolute.  To check this you must open ~\/.bash_profile (or ~\/.bashrc); you're looking for a line that looks like the following, if you can't find, you'll need to add it.  export PATH=~\/.composer\/vendor\/bin:$PATH   Install Per Project Using Composer  cd \/your\/project\/folder composer require aklump\/visual-sitemap   Testing installation   Test your installation by typing vismap in your terminal, you should see:  Argument 1 must point to a configuration json file.    Usage   Create the configuration JSON file following the schema.  Use example.json and quick_start.json as guides.  If you wish to use the CLI to create the file (which copies and renames quick_start.json) do the following:  cd \/the\/dir\/to\/contain\/the\/config vismap FILENAME.json -c  You can also refer to schema.json, which uses JSON Schema to define the format of the configuration file. Generate an HTML version once by running the following command: vismap sitemap.json.  sitemap.html will be created.  If sitemap.html already exists, you will need to use the -f flag to overwrite it, e.g. vismap sitemap.json -f. A file watch command is availabe.  As you make changes to the JSON file, the sitemap will automatically be re-generated.  Use vismapwatch sitemap.json for this.  Again, use the -f flag if the HTML file already exists. Use the --out={filepath} to control the output location relative to the source file.  You may also use an absolute path beginning with a \/.   Best Practices   Do not change the order of items in the JSON file, unless you intend to change the section numbers associated with the items.  That is to say, always append new items to the end of a section array.  Failure to follow this point will result in your section numbers being reassigned to different sections.  ","tags":"","url":"README.html"},{"title":"Tasklist","text":"  - [ ] ld--roadmap: Fix the delay caused by deleting files at beginning of compile. - [ ] ld--todos: a task list item - [ ] ld--todos: a task list item @w-10 - [ ] demos--md_extra: Todo items will get aggregated automatically @w10 - [ ] ld--todos: a task list item @w10 - [ ] ld--todos: a task list item @w10.1  ","tags":"","url":"_tasklist.html"},{"title":"Integration with Loft Docs","text":"  This document will describe a method of adding your sitemap to documentation per Loft Docs.  The File Structure  docs \u251c\u2500\u2500 hooks \u2502\u00a0\u00a0 \u2514\u2500\u2500 sitemap.sh \u251c\u2500\u2500 sitemap \u2502\u00a0\u00a0 \u251c\u2500\u2500 html.twig * \u2502\u00a0\u00a0 \u2514\u2500\u2500 sitemap.json \u2514\u2500\u2500 source     \u2514\u2500\u2500 sitemap.md    Optional, template override   Instructions   Create a hook file called sitemap.sh with the following, this will handle the generation during documentation compilation.  #!\/usr\/bin\/env bash  docs_vismap=$(type vismap &gt;\/dev\/null &amp;2&gt;&amp;1 &amp;&amp; which vismap)  if [ \"$docs_vismap\" ]; then     cd \"$1\" &amp;&amp; $docs_vismap \"$4\/sitemap\/sitemap.json\" --out=\"$9\/vismap.html\" -f --theme=\"$4\/sitemap\" &amp;&amp; exit 0     exit 1 fi  Register the hook file.  Add the filename to core-config.sh to the pre_hooks var:  pre_hooks = \"sitemap.sh\"  Create a folder docs\/sitemap. Create your sitemap json in docs\/sitemap\/sitemap.json. Optional, place template overrides in docs\/sitemap. Create a wrapper file called sitemap.md with something like the following; the iframe is the important part.  You may add other content as necessary around the iframe.  # Visual Sitemap  &lt;iframe src=\"vismap.html\" height=\"1200\"&gt;&lt;\/iframe&gt;  Now compile your documentation and ensure all is as expected.  You can use vismap.html as a standalone file, or you can view it wrapped by sitemap.html as part of the documentation.  ","tags":"","url":"loft-docs.html"},{"title":"How to Write the Sitemap Definition","text":"  Review example.json and quick_start.json for examples of actual schemas.  The schema is very simple, a nested group of objects, each following this pattern:  {     \"title\": \"\",     \"more\": \"\",     \"type\": \"\",     \"path\": \"\",     \"sections\": [] }   Top-Level  The top-level node only, takes the following additional keys:   baseUrl Used to generate URL tokens. footer Optional footer text. subtitle Optional subtitle. timezone The timezone name to localize to.   Nesting  The sections is where you nest the nodes, like this:  {     \"sections\": [         {             \"title\": \"\",             \"more\": \"\",             \"type\": \"\",             \"path\": \"\",             \"sections\": [                 {                     \"title\": \"\",                     \"more\": \"\",                     \"type\": \"\",                     \"path\": \"\",                     \"sections\": []                 }             ]         },         {             \"title\": \"\",             \"more\": \"\",             \"type\": \"\",             \"path\": \"\",             \"sections\": []         }     ] }   Types  The following are the valid section types.  You may omit the type and page is implied, which is the default type.   page This represents a page on the site, with a unique path. content This represents content on a page. link This represents a link to another page on the site. external This represents a link to another, external website. modal This represents a modal or popoup. download This represents a download file. form This represents a form.   Path  Path should be a relative link and begin with \/.  Not all resources should use path.  Use URL placeholders, e.g. user\/{user}.  More (Info)  Optional, URL hyperlink to anything that provides more info for the section, a Trello card, website, documentation, etc.  This makes the title clickable.  You may use tokens in this field, the following are available:       token   description       {{ url }}   An absolute URL generated using the baseUrl and the path of the section     {{ path }}   The path of the section     {{ base }}   The value of the baseUrl configuration variable    ","tags":"","url":"schema.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"},{"title":"How to Use States For Sitemap Variations","text":"  The idea with states is that your website may have a different sitemap based on a given state: admin is logged in, user has a different role, etc.  With states you will define a monolithic site map and then by applying a state at the display level, you can have different layouts or perspectives.   A given state must not contain a space char; user-logged-in is good, while user logged in is not allowed. The value of state may be one or more states separated by a space. State may also be wildcard * which means it will appear in all states. A wildcard can be followed by a negative state, e.g.,  * !admin which means it will appear in all states, except the negated one, in this case admin. If a section does not explicitly declare a state key, it will inherit it's parent's state.  To block inheritance, set the state to an empty string. To implement a state when you generate the sitemap, pass the --state=STATE To generate all files at once, for all states, pass --state=*   State Inheritance Demonstrated  Given the following sitemap definition...      {         \"state\": \"*\",         \"sections\": [             {                 \"title\": \"About Membership\",                 \"sections\": [                     {                         \"title\": \"Sign Up\",                         \"state\": \"\"                     },                     {                         \"title\": \"Benefits\"                     },                     {                         \"title\": \"Your Account Info\",                         \"state\": \"member\"                     },                     {                         \"title\": \"Your Affiliate Info\",                         \"state\": \"member affiliate\"                     }                 ]             },             {                 \"title\": \"All Members\",                 \"state\": \"admin\",                 \"sections\": [                     {                         \"title\": \"Delete\"                     }                 ]             },             {                 \"title\": \"Contact\",                 \"state\": \"* !admin\"             }         ]     }   The calculated states are as follows:       Section Title   Calculated state   Why?   Visible Only When       About Membership   admin affiliate member   inherited from *   state is admin, affiliate or member     Signup   -   empty prevents inheritence   state is not set     Benefits   admin affiliate member   inherited from About Membership   state is admin, affiliate or member     Your Account Info   member   explicit   state is member     Your Affiliate Info   member affiliate   explicit, multi-value   state is member or affiliate     All Members   admin   explicit   state is admin     Delete   admin   inherited from All Members   state is admin     Contact   affiliate member   * expands to all, !admin removes admin   state is affiliate or member    ","tags":"","url":"states.html"},{"title":"How to Override the Markup (Custom Theming)","text":"  You may override the default templates by creating your own overrides directory.  So if wanted to refactor html.twig then first copy it to YOUR_THEME_DIR\/html.twig and then modify as desired.  For user styles, add a file called style.css to the same directory and it will be included in the sitemap.  For these themes to be discovered you must pass the --theme=\/PATH\/TO\/DIRECTORY parameter, e.g.  . \/vendor\/bin\/vismap website.json --theme=templates   In the above example you will have a directory structure something like the following, and you have installed Visual Sitemap at the project level.  website.json is your config file.  You have created your own theme and styles in templates.  . \u251c\u2500\u2500 templates \u2502\u00a0\u00a0 \u251c\u2500\u2500 html.twig \u2502\u00a0\u00a0 \u2514\u2500\u2500 style.css \u251c\u2500\u2500 vendor \u2502\u00a0\u00a0 \u2514\u2500\u2500 bin \u2502\u00a0\u00a0     \u2514\u2500\u2500 vismap \u2514\u2500\u2500 website.json  ","tags":"","url":"theming.html"}]};
