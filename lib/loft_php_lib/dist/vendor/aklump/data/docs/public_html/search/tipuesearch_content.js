var tipuesearch = {"pages":[{"title":"CHANGELOG","text":"  {version}   {description of change}  ","tags":"","url":"CHANGELOG.html"},{"title":"Data","text":"  Summary  Provides a common means for getting data from objects or arrays with default option such as Lodash's get method.  Other methods for working with array\/object data will be added in time.  Rationale  Given a multidimensional array, in vanilla PHP you will do this:  print isset($multi_array['do']['re']) ? $multi_array['do']['re'] : 'default';   Using this class you would do this:  $data = new Data; print $data-&gt;get($multi_array, 'do.re', 'default');   Not too impressive... but wait... imagine when you have complex objects, like say a Drupal 7 field value translated into spanish.  print isset($node-&gt;field_description['es']['1']['value']) ? $node-&gt;field_description['es']['1']['value'] : '';  \/\/ vs...  print $data-&gt;get($node, 'field_description.1.value', '');   Or when you need to work in Drupal 8 for a few days.  print isset($node-&gt;field_description) ? $node-&gt;get('field_description')-&gt;get(1)-&gt;value : '';  vs.  print $data-&gt;get($node, 'field_description.1.value', '');   This is where a consistent interface approach starts to make sense.  By the way, there is a Drupal module that uses a different implementation of this class which can be found here.  Default value  Every call to ::get can have a default value, which removes the need for if\/thens or issets.  $country = $data-&gt;get($record, 'home.address.country', 'U.S.');   Callback  You can pass a callback to process the value such as loading a record by id.  $url = $data-&gt;get($record, 'picture.id', 'http:\/\/mysite.com\/default.jpg', function($id) {     return load_url_by_record_id($id); });   Details  &lt;?php use AKlump\\Data\\Data;  $data = new Data;  \/\/ Let's create a data subject, from which we want to pull data. $a = array('b' =&gt; array('c' =&gt; 'd'));  \/\/ First let's pull data that exits. \/\/ Because $a['b']['c'] has a value 'd', it will be returned.  Default is ignored. $value = $data-&gt;get($a, 'b.c', 'e'); $value === 'c';  \/\/ Because $a['b']['z'] is not set then the default value comes back, 'e'. $value = $data-&gt;get($a, 'b.z', 'e'); $value === 'e';  \/\/ This interface works on objects or arrays, regardless.  Let's convert this to a nested object using json functions. $a_object = json_decode(json_encode($a));  \/\/ Make the same call and you'll get the same answer. $value = $data-&gt;get($a, 'b.c', 'e'); $value === 'c';   Data::set()  Unconditionally sets a value at path.  Data::ensure()  Ensures that a path is set, does not overwrite if the key\/property exists.  Data::fill()  This is a conditional setter method.  It will fill in only if a path is empty (or based on some other test see example 3).  Example 1  &lt;?php \/\/ In this case the value is filled in. $array = array('do' =&gt; ''); $data-&gt;fill($array, 'do', 're');  \/\/ The value is filled in because the current value is empty. $array === array('do' =&gt; 're');   Example 2  &lt;?php \/\/ In this case the value is NOT. $array = array('do' =&gt; null); $data-&gt;fill($array, 'do', 're', 'strict');  \/\/ The old value of null remains because 're' is a string and the current value not a string; even though it's empty, it will not be replaced because we've used the 'strict' test. $array === array('do' =&gt; null);    Example 3  &lt;?php \/\/ In this case the value is replaced based on a callback. $array = array('do' =&gt; 45); $data-&gt;fill($array, 'do', 're', function ($current, $exists) {     return $exists &amp;&amp; is_numeric($current); });  \/\/ The value is replaced because our custom callable tested it as a number and returned true. $array === array('do' =&gt; 're');   Acknowledgments   Thank you Aaron Jensen (https:\/\/github.com\/aaronjensen) for introducing me to this concept. https:\/\/lodash.com\/docs\/4.16.2#get  ","tags":"","url":"README.html"},{"title":"Using the \"onlyIf\" method for conditionals","text":"  Let's assume this setup:  &lt;?php $from = ['id' =&gt; '123']; $to = []; $obj = new Data;   Passing values from one to another  The scenario is this: you want to pass a value from one array to another, only if that value is present in the first array.  $obj-&gt;onlyIf($from, 'id')-&gt;set($to); \/\/ $to['id'] === '123'  $obj-&gt;onlyIf($from, 'title')-&gt;set($to); \/\/ $to === []   Same as above only we will use a new path in the final array:  $obj-&gt;onlyIf($from, 'id')-&gt;set($to, 'account.id');  \/\/ $to['account']['id'] === '123'   Execution stops with the conditional  When a conditional is used, anything chained after it will not do it's job e.g., filter will not be called; call will not fire callbacks, etc.  This is illustrated in the following examples.  $word = array('flying' =&gt; 'bird'); $plural = $obj-&gt;onlyIf($word, 'flying')-&gt;call(function ($value) {     return $value . 's'; })-&gt;value(); \/\/ $value === 'birds'  $word = array('flying' =&gt; 'bird'); $plural = $obj-&gt;onlyIf($word, 'creeping')-&gt;call(function ($value) {     return $value . 's'; })-&gt;value(); \/\/ $value === null   Here is another real world example of how you could validate an incoming request, throwing an exception if the request is invalid.  $totalPages = get_total_pages(); $page = $obj-&gt;onlyIfHas($_GET, 'page')           -&gt;call('intval')           -&gt;call(function ($page) use ($totalPages) {               if ($page &lt; 1 || $page &gt; $totalPages) {                   throw new \\InvalidArgumentException(\"Page number is invalid.\");               }                return $page;           })           -&gt;value();    If the incoming request does not contain $_GET['page'], $page will be set to null. If the incoming $_GET['page'] is a valid page number, it will be converted to an int and then assigned to $page. If $_GET['page'] is present but outside the range of pages, the exception is thrown.  $page will never be set; this is important depending upon how you catch the exception.   Using a test callback  By passing a third argument--a callback that takes the value as it's parameter and returns true if the value should be used--you can customize how this method works.  $from = array('name' =&gt; 'bob'); $value = $this-&gt;data-&gt;onlyIf($from, 'name', function ($value) {     return substr($value, 0, 1) === 'a'; })-&gt;value();  \/\/ $value === null;   In Summary          onlyIf   onlyIfHas   onlyIfNull       requires key\/property   Y*   Y   -     passes if null   -*   Y   Y     custom test   Y   -   -     * you may alter this with a custom test callback ","tags":"","url":"conditionals.html"},{"title":"How to read in from the defined variables","text":"  You can use this class to read from variables quite easily.  For example of you want to get the value of $foo and you don't know if $foo is defined or not, you can do the following and leverage the footprint of Data.  $foo = 'white'; ... $result = $this-&gt;data-&gt;get(get_defined_vars(), 'foo', 'black');  \/\/ $result === 'white'   $result = $this-&gt;data-&gt;get(get_defined_vars(), 'bar', 'black');  \/\/ $result === 'black'   get_defined_vars() only works in the current scope.  Learn about get_defined_vars(). ","tags":"","url":"defined-vars.html"},{"title":"Reading Data","text":"  Here are some examples of how this class is used to get data out of an object or array.  The examples use an array, but they would work equally well with standard class objects, and other objects with public properties or magic getters, or a get() method.  For all examples, assume the following setup:  &lt;?php $data = ['id' =&gt; '123', 'email' =&gt; 'me@there.com']; $obj = new Data;   Example One: Simple  Simple. No transformation. Data is present.  $result = $obj-&gt;get($data, 'id');  \/\/ $result === '123';   Example Two: Using Default  Simple. With Default. Data not present.  $result = $obj-&gt;get($data, 'name', 'anonymous');  \/\/ $result === 'anonymous';   Example Three: Transformation Callbacks  The callback receives three arguments:   The computed value; this will be the default if the path doesn't exist. The original default value. true if the path existed; a.k.a. true if the default is NOT being used.   Transformation to integer.  Notice that the transformation callback can do anything to the value you want.  It just happens to convert to integer in this example.  $result = $obj-&gt;get($data, 'id', null, function ($value, $default, $exists) {     return $value ? intval($value) : $default; });  \/\/ $result === 123   Example Four: Shorthand method(s)  ... instead of callback, try using getInt() method, which is far less verbose ...  $result = $obj-&gt;getInt($data, 'id');  \/\/ $result === 123   Example Five: Chaining  A contrived example as you would just use get() in such a case, but this demonstrates a point: how to get a value through chaining.  The getThen() method returns an instance of the object, not the value.  You have to use the value() method to return the value itself.  $result = $obj-&gt;getThen($data, 'id')               -&gt;value();  \/\/ $result === '123'   Example Six: Chaining with filter  getThen() is really meant for leveraging the filter() method.  $result = $obj-&gt;getThen($data, 'email')               -&gt;filter(FILTER_SANITIZE_EMAIL)               -&gt;value();  \/\/ $result === 'me@there.com'  ","tags":"","url":"read.html"},{"title":"Search Results","text":" ","tags":"","url":"search--results.html"},{"title":"Transformations","text":"  If the transformation is occurring as you pull data out of the subject, then it is probably less verbose to simply use the fourth parameter of the get() method, the value callback.  If, however, you want to transform the value inside of $subject, then this page will advise on how to do that.  Transform with a function name  The function must only take a single parameter, which is the $value.  To use a function with a different signature, wrap it in an anonymous function.  This example will transform a value via strtoupper(), observe:  $subject = array('name' =&gt; 'bob'); $obj-&gt;getThen($subject, 'name')-&gt;call('strtoupper')-&gt;set($subject);  \/\/ $subject['name'] === 'BOB';   This example will assign it to a different key:  $subject = array('name' =&gt; 'bob'); $obj-&gt;getThen($subject, 'name')-&gt;call('strtoupper')-&gt;set($subject, 'ucname');  \/\/ $subject['name'] === 'bob'; \/\/ $subject['ucname'] === 'BOB';   Transform with an anonymous function  $from = array('being' =&gt; 'dog'); $obj-&gt;getThen($from, 'being')     -&gt;call(function ($value) {         $value = str_split($value);         $value = array_reverse($value);          return implode($value);     })     -&gt;set($from);  \/\/ $from['being'] === 'god';   Transform with arguments  Additional arguments to call() will be sent to the callable as arguments.  This is the same as call_user_func_array() which is used under the hood.  class MyClass {     public static function Concat()     {         return implode('.', func_get_args());     } } ... $result = $obj-&gt;onlyIf($data, 'id')               -&gt;call('MyClass::Concat', 'do', 're', 'mi')               -&gt;value();  \/\/ $result === 'id.do.re.mi';  ","tags":"","url":"transform.html"},{"title":"Ways to Write Data","text":"  set() vs. ensure() vs. fill()  To understand these methods, lets' use a metaphore.  Imagine a table with nothing on it.  On the floor is a bucket, inside of which is a banana.  Next to the bucket is an apple.  Using set() is akin to placing the bucket on the table, removing the banana and putting the apple inside the bucket.   The table is your containing variable. The bucket is the path inside the variable. The banana is the old value at the path. The apple is the new value a the path.   ensure()  Start with an empty table, an empty bucket on the floor and the apple.  After calling ensure, we have a bucket with the apple in it on the table.  Now consider the same scenario but the bucket has the banana in it to start with, and the bucket is on the floor.  After calling ensure, we have a bucket still with a banana in it, but the bucket is on the table.  Lastly, think of the table with a bucket on it containing the banana.  After calling ensure you would see no change.  When you call ensure(), you ensure there is a bucket on the table, if not you put one there.  Then we look inside the bucket on the table to see if it's empty, if so we place the apple inside of it.  fill()  If you understand ensure() then you should be able to get fill() rather quickly.  Calling fill will not place the bucket on the table, only fill it if it's already on the table AND it's empty.  How a bucket is considered empty is configurable, so refer to the docblocks for that.  set()  So with those out of the way, set() is a piece of cake.  Set doesn't care if there is a bucket on the table or not.  Set will walk up to the table grab the bucket, dump it out, set it on the table, and put the apple in it.  No consideration of anything.  In Summary          set   ensure   fill       guarantees key\/property   Y   Y   -     overwrites current value   Y   -   only if empty      Use fill() if you want to make sure no value is empty, but do not want to add the key\/property if non-existent. Use ensure() if you only care that a key\/property is set, but not the value. Use set() if you want to overwrite current values, while knowing that a key\/property is surely set. Use the getThen()-&gt;...-&gt;set() chain with a value callback or filter if you just want to transform a value.  ","tags":"","url":"write--ways.html"}]};
